local U = z_idiots_utils
local C = z_idiots_companions


EVAL_FACER          = xrs_facer.evid_facer
EVAL_FACER_STEAL_UP = xrs_facer.evid_steal_up_facer
EVAL_ENEMY          = stalker_ids.property_enemy
EVAL_LOGIC          = xr_evaluators_id.state_mgr + 4
EVAL_CAMPER         = xr_evaluators_id.combat_camper_base
EVAL_MONOLITH       = xr_evaluators_id.combat_monolith_base
ACTION_CAMPER       = xr_actions_id.combat_camper_base
ACTION_MONOLITH     = xr_actions_id.combat_monolith_base


local __combat_evaluate = xr_combat.evaluator_check_combat.evaluate
local __try_go_cover    = axr_fight_from_cover.action_fight_from_cover.try_go_cover
local __is_enemy        = xr_combat_ignore.is_enemy


-- utils: combat --

TEAM_SIGHT  = true
SEE_TIME    = {5000, 7000}
SEARCH_TIME = {5000, 7000}
ROTATE_TIME = {1000, 2000}

COMBAT_ANIMATIONS = {
  stand = {
    idle = {
      snipe  = "threat_sniper_fire",
      fire   = "threat_fire",
      reload = "hide_fire",
      hold   = "threat_na",
    },
    move = {
      snipe  = "assault_fire",
      fire   = "assault_fire",
      reload = "assault_fire",
      hold   = "assault",
    }
  },
  sneak = {
    idle = {
      snipe  = "hide_sniper_fire",
      fire   = "hide_fire",
      reload = "hide_fire",
      hold   = "hide_na",
    },
    move = {
      snipe  = "assault_fire",
      fire   = "assault_fire",
      reload = "assault_fire",
      hold   = "assault",
    }
  },
  prone = {
    idle = {
      snipe  = "prone_sniper_fire",
      fire   = "prone_fire",
      reload = "prone_fire",
      hold   = "prone_idle",
    },
    move = {
      snipe  = "sneak_fire",
      fire   = "sneak_fire",
      reload = "sneak_fire",
      hold   = "sneak_run",
    }
  }
}


function U.updateEnemy(npc, st)
  local enemy = npc:best_enemy()

  st.enemyID      = nil
  st.enemySeen    = false
  st.enemyPredict = false
  st.enemyWounded = false

  if not (enemy and enemy:alive()) then
    st.enemyPos   = nil
    st.enemyDist  = nil
    st.searchTime = nil
    st.seeTime    = nil
    return
  end

  st.enemySeen    = npc:see(enemy)
  st.enemyPredict = st.seeTime and time_global() <= st.seeTime

  local newPos = nil

  if st.enemySeen then
    U.resetEnemyTimers(st)
    newPos = enemy:position()

  elseif TEAM_SIGHT and U.teamSeesEnemy(npc, enemy) then
    U.resetEnemyTimers(st)
    newPos = enemy:position()

  elseif st.enemyPredict then
    newPos = enemy:position()

  elseif npc:memory_position(enemy) then
    newPos = npc:memory_position(enemy)
  end

  if newPos then
    st.enemyPos     = newPos
    st.enemyID      = enemy:id()
    st.enemyWounded = IsWounded(enemy)
    st.enemyDist    = npc:position():distance_to(newPos)
  end
end


function U.resetEnemyTimers(st)
  st.searchTime = time_global() + U.random(SEARCH_TIME[1], SEARCH_TIME[2])
  st.seeTime    = time_global() + U.random(SEE_TIME[1], SEE_TIME[2])
end


function U.getCombatMoveState(npc, st)
  local cover = st.coverFn(npc, st.enemyPos)
  local keys  = {"stand", "idle", "hold"}

  if C.getState(npc, "PRONE") then
    keys[1] = "prone"
  elseif C.getState(npc, "SNEAK") then
    keys[1] = "sneak"
  end

  if not st.reached then
    keys[2] = "move"
  elseif cover.mid then
    keys[1] = "stand"
  elseif cover.low and keys[1] == "prone" then
    keys[1] = "sneak"
  end

  if st.status == "RELOAD" then
    keys[3] = "reload"
  elseif st.enemySeen and IsSniper(npc:active_item()) then
    keys[3] = "snipe"
  elseif st.enemySeen then
    keys[3] = "fire"
  end

  return COMBAT_ANIMATIONS[keys[1]][keys[2]][keys[3]]
end


function U.getCombatLookState(npc, st)
  if st.enemySeen then
    return {look_object = level.object_by_id(st.enemyID)}
  end

  local dir = st.enemyPos
    and vdir(npc:position(), st.enemyPos)
    or  npc:direction()

  if not st.reached or st.enemyPredict then
    return {look_dir = dir}
  end

  local fov = C.getState(npc, "PRONE")
    and 40 or 80

  if not st.rotateFn then
    st.rotateFn = U.throttle(U.randomRotate, ROTATE_TIME[1], ROTATE_TIME[2])
  end

  return {look_dir = st.rotateFn(dir, fov)}
end


function U.teamSeesEnemy(npc, enemy)
  if not U.isCompanion(npc) then
    return U.squadSeesEnemy(npc, enemy)
  end

  if db.actor:see(enemy) then
    return true
  end

  for i, companion in ipairs(U.getCompanions()) do
    if companion:see(enemy) then
      return true
    end
  end

  return false
end


function U.squadSeesEnemy(npc, enemy)
  local squad = get_object_squad(npc)

  if squad then
    for member in squad:squad_members() do
      local squaddie = U.getNPC(member.id)

      if squaddie and squaddie:see(enemy) then
        return true
      end
    end
  end

  return false
end


-- shared scripted combat evaluator
class "evaluator_combat_type" (property_evaluator)


function evaluator_combat_type:__init(name, storage, type) super(nil, name)
  self.st   = storage
  self.type = type
end


function evaluator_combat_type:evaluate()
  return db.storage[self.object:id()].script_combat_type == self.type
end


-- shared scripted combat callback to update enemy position when hit
function hit_callback(self, obj, amount, direction, who, bone)
  if not who then
    return
  end

  local st    = self.st
  local npc   = self.object
  local enemy = npc:best_enemy()

  if enemy and enemy:id() == who:id() then
    U.resetEnemyTimers(st)
    st.enemyPos = who:position()
  end
end


-- fix: update combat type before evaluating
-- prevents NPCs from getting permanently stuck in scripted combat
function xr_combat.evaluator_check_combat:evaluate()
  xr_combat.set_combat_type(self.object, db.actor, self.st)
  return __combat_evaluate(self)
end


-- fix: prevent stealthy companions and enemies from ignoring each other by
-- temporarily removing their companion flags to bypass a buggy if statement
-- in the original function
function xr_combat_ignore.is_enemy(npc, enemy, no_memory)
  local isNpcCompanion       = npc:has_info("npcx_is_companion")
  local isEnemyCompanion     = enemy:has_info("npcx_is_companion")
  local isNpcSneaking        = npc:has_info("npcx_beh_substate_stealth")
  local isEnemySneaking      = enemy:has_info("npcx_beh_substate_stealth")
  local isNpcFightingActor   = xr_combat_ignore.fighting_with_actor_npcs[npc:id()]
  local isEnemyFightingActor = xr_combat_ignore.fighting_with_actor_npcs[enemy:id()]
  local isWithin30meters     = enemy:position():distance_to_sqr(npc:position()) < 900

  -- to be extra safe, only apply fix if all of these conditions are not met
  if
    not    (isNpcCompanion or isEnemyCompanion)
    or not (isNpcSneaking or isEnemySneaking)
    or     (isNpcFightingActor or isEnemyFightingActor)
    or not isWithin30meters
  then
    return __is_enemy(npc, enemy, no_memory)
  end

  local function disableCompanionInfo()
    npc:disable_info_portion("npcx_is_companion")
    enemy:disable_info_portion("npcx_is_companion")
  end

  local function restoreCompanionInfo()
    if isNpcCompanion then
      npc:give_info_portion("npcx_is_companion")
    end
    if isEnemyCompanion then
      enemy:give_info_portion("npcx_is_companion")
    end
  end

  -- disable after on_enemy_eval is complete (this should be the last callback)
  RegisterScriptCallback("on_enemy_eval", disableCompanionInfo)

  -- restore as soon as possible (before is_enemy() calls this funciton)
  local ignoreByOverrides = xr_combat_ignore.ignore_enemy_by_overrides

  function xr_combat_ignore.ignore_enemy_by_overrides(...)
    restoreCompanionInfo()
    xr_combat_ignore.ignore_enemy_by_overrides = ignoreByOverrides
    return ignoreByOverrides(...)
  end

  local isEnemy = __is_enemy(npc, enemy, no_memory)

  -- restore again in case is_enemy() returned early
  restoreCompanionInfo()
  UnregisterScriptCallback("on_enemy_eval", disableCompanionInfo)

  return isEnemy
end


-- fix: replace try_go_cover() to help nudge companions closer to enemies
-- so they don't just shuffle around in one place far away forever
-- I'll rewrite axr_fight_from_cover later
function axr_fight_from_cover.action_fight_from_cover:try_go_cover(npc, enemyPos)
  if not U.isCompanion(npc) then
    return __try_go_cover(self, npc, enemyPos)
  end

  local vid = U.findBestCover(npc, enemyPos)

  if not U.isValidLVID(npc, vid) then
    return
  end

  self.st.vid = vid
  U.setDestination(npc, vid)
  U.claimLVID(npc, vid)

  return vid
end


--[[ TEMP
-- 0 = released / 1 = pressed \ 2 = held
axr_keybind.bind("kCUSTOM3",function(p)
  move_to_point(p)
end)

function on_key_release(key)
  local bind = dik_to_bind(key)
  if (bind == key_bindings.kCUSTOM18) then
    start_CW()

  elseif (bind == key_bindings.kCUSTOM1) then
    cycle_companions_combat_mode()

  elseif (bind == key_bindings.kCUSTOM2) then
    cycle_companions_move_mode()

  elseif (bind == key_bindings.kCUSTOM3) then
    --move_to_point(p)

  elseif (bind == key_bindings.kCUSTOM4) then
    cycle_companions_stealth_mode()

  elseif (bind == key_bindings.kCUSTOM5) then
    cycle_companions_loot_mode()

  end
end

local _draw_part

function move_to_point(pressType)
  local lvid

  if pressType == 1 then
    actor_menu.set_msg(1, game.translate_string("st_hold_then_release"), 8)
    _draw_part = particles_object("_samples_particles_\\flash_light")

  elseif pressType == 2 then
    if _draw_part then
      local r = level.get_target_dist and level.get_target_dist()

      if (r) then
        lvid = level.vertex_in_direction(
          level.vertex_id(device().cam_pos),
          device().cam_dir,
          r
        )

        local pos = level.vertex_position(lvid)

        _draw_part:play_at_pos(
          vector():set(pos.x, pos.y - 0.5, pos.z)
        )
      end
    end

  else
    if _draw_part then
      _draw_part:stop()
      _draw_part = nil
    end

    local r = level.get_target_dist and level.get_target_dist()

    if (r) then
      lvid = level.vertex_in_direction(
        level.vertex_id(device().cam_pos),
        device().cam_dir,
        r
      )

      if (lvid) then
        actor_menu.set_msg(1, game.translate_string("st_move_to_point"), 8)

        for id, squad in pairs(companion_squads) do
          if (squad and squad.commander_id) then
            for k in squad:squad_members() do
              st = db.storage[k.id]
              local member = st and st.object

              if (member and member:alive()) then
                set_companion_to_follow_state(member)
                save_var(member, "fight_from_point", lvid)
              end

              if (k.id == squad:commander_id() and not axr_task_manager.hostages_by_id[k.id]) then
                if (st and st.beh) then
                  st.beh.rally_lvid = lvid
                end
              end
            end
          end
        end
      end
    end
  end
end
--]]
